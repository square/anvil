package com.squareup.anvil.compiler.codegen

import com.google.common.truth.Truth.assertThat
import com.squareup.anvil.compiler.api.AnvilContext
import com.squareup.anvil.compiler.api.CodeGenerator
import com.squareup.anvil.compiler.api.GeneratedFile
import com.squareup.anvil.compiler.compile
import com.squareup.anvil.compiler.internal.testing.simpleCodeGenerator
import com.squareup.anvil.compiler.isError
import com.tschuchort.compiletesting.KotlinCompilation.ExitCode.OK
import org.jetbrains.kotlin.descriptors.ModuleDescriptor
import org.jetbrains.kotlin.psi.KtFile
import org.junit.Test
import java.io.File

class CodeGenerationExtensionTest {

  @Test fun `generated files with the same path and different content are an error`() {
    val codeGenerator = simpleCodeGenerator { clazz ->
      clazz
        .takeIf { it.isInterface() }
        ?.let {
          //language=kotlin
          """
          package generated.com.squareup.test
          
          class Abc
          
          private const val abc = "${clazz.shortName}"
        """
        }
    }

    compile(
      """
      package com.squareup.test

      interface ComponentInterface1
      
      interface ComponentInterface2
      """,
      codeGenerators = listOf(codeGenerator),
    ) {
      assertThat(exitCode).isError()

      // Replacing the character is necessary for running the tests on Windows.
      assertThat(messages.replace('\\', '/')).contains(
        "There were duplicate generated files. Generating and overwriting the same file " +
          "leads to unexpected results. The relative path is: " +
          "generated/com/squareup/test/Abc.kt. The file was generated by class " +
          "com.squareup.anvil.compiler.internal.testing.SimpleCodeGeneratorKt" +
          "\$simpleCodeGenerator\$1. The input files were [Source0.kt].",
      )
    }
  }

  @Test fun `generated files with the same path and same content are allowed`() {
    val codeGenerator = simpleCodeGenerator { clazz ->
      clazz
        .takeIf { it.isInterface() }
        ?.let {
          //language=kotlin
          """
          package generated.com.squareup.test
          
          class Abc
        """
        }
    }

    compile(
      """
      package com.squareup.test

      interface ComponentInterface1
      
      interface ComponentInterface2
      """,
      codeGenerators = listOf(codeGenerator),
    ) {
      assertThat(exitCode).isEqualTo(OK)
    }
  }

  @Test fun `a code generator that is not applicable is never called`() {
    var isApplicableCalled = false
    var generateCodeCalled = false

    val codeGenerator = object : CodeGenerator {
      override fun isApplicable(context: AnvilContext): Boolean {
        isApplicableCalled = true
        return false
      }

      override fun generateCode(
        codeGenDir: File,
        module: ModuleDescriptor,
        projectFiles: Collection<KtFile>,
      ): Collection<GeneratedFile> {
        generateCodeCalled = true
        return emptyList()
      }
    }

    compile(
      """
      package com.squareup.test

      interface ComponentInterface1
      """,
      codeGenerators = listOf(codeGenerator),
    ) {
      assertThat(exitCode).isEqualTo(OK)
      assertThat(isApplicableCalled).isTrue()
      assertThat(generateCodeCalled).isFalse()
    }
  }

  @Test fun `errors that require an opt-in annotation are suppressed in generated code`() {
    compile(
      """
      package com.squareup.test

      import com.squareup.anvil.annotations.ContributesBinding
      import javax.inject.Inject

      @Retention(AnnotationRetention.BINARY)
      @RequiresOptIn(
          message = "",
          level = RequiresOptIn.Level.ERROR
      )
      @MustBeDocumented
      annotation class InternalApi

      interface Type

      @InternalApi
      @ContributesBinding(Unit::class)
      class SomeClass @Inject constructor() : Type 
      """,
    ) {
      assertThat(exitCode).isEqualTo(OK)
    }
  }
}
