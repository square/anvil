package com.squareup.anvil.compiler.codegen.incremental

import com.rickbusarow.kase.stdlib.createSafely
import io.kotest.matchers.shouldBe
import org.junit.Test

internal class FileCacheOperationsTest : CacheTests {

  @Test
  fun `cached bindings are preserved when reading the cache from a file`() = test {

    fileOperations.addToCache(
      gen1.withSources(source1),
      gen2.withSources(source2),
    )

    val newCache = newCache()

    newCache.rootSourceFiles shouldBe setOf(source1, source2)

    newCache.getGeneratedFilesRecursive(source1) shouldBe setOf(gen1.relativeFile)
    newCache.getGeneratedFilesRecursive(source2) shouldBe setOf(gen2.relativeFile)
  }

  @Test
  fun `restoreFromCache passing a source file as input deletes it and everything downstream`() = test {

    fileOperations.addToCache(
      gen1.withSources(source1),
      gen2.withSources(source2),
      gen3.withSources(gen2.toSourceFile()),
      gen4.withSources(source3),
    )

    listOf(gen1, gen2, gen3)
      .forEach { it.file.delete() }

    fileOperations.restoreFromCache(generatedDir, setOf(source2))

    currentFiles() shouldBe listOf(
      gen1.relativeFile,
      gen4.relativeFile,
      source1,
      source2,
      source3,
    )
  }

  @Test
  fun `restoreFromCache missing generated files are restored`() = test {

    fileOperations.addToCache(
      gen1.withSources(source1),
      gen2.withSources(source2),
      gen3.withSources(gen2.toSourceFile()),
    )

    listOf(gen1, gen2, gen3)
      .forEach { it.file.delete() }

    fileOperations.restoreFromCache()

    currentFiles() shouldBe listOf(
      gen1.relativeFile,
      gen2.relativeFile,
      gen3.relativeFile,
      source1,
      source2,
    )

    source1.absoluteFile shouldExistWithText "content for source1.kt"
    source2.absoluteFile shouldExistWithText "content for source2.kt"

    gen1.file shouldExistWithText gen1.content
    gen2.file shouldExistWithText gen2.content
    gen3.file shouldExistWithText gen3.content
  }

  @Test
  fun `restoreFromCache restores generated files with generated sources`() = test {

    // The Gradle plugin passes the source file argument by grabbing all source files from the
    // source set, so for an incremental build that can include generated files.

    fileOperations.addToCache(
      gen1.withSources(source1),
      gen2.withSources(source2),
      gen3.withSources(gen2.toSourceFile()),
    )

    fileOperations.restoreFromCache()

    currentFiles() shouldBe listOf(
      gen1.relativeFile,
      gen2.relativeFile,
      gen3.relativeFile,
      source1,
      source2,
    )
  }

  @Test
  fun `restoreFromCache deletes a generated file with no source files when any source changes`() =
    test {

      fileOperations.addToCache(
        gen1,
        gen2.withSources(source1, source2),
        gen3.withSources(source2),
      )

      source1.writeText("changed")

      fileOperations.restoreFromCache(source1)

      currentFiles() shouldBe listOf(gen3.relativeFile, source1, source2)
    }

  @Test
  fun `restoreFromCache deletes the files generated by a changed source file`() = test {

    fileOperations.addToCache(
      gen1.withSources(source1),
      gen2.withSources(source2),
      gen3.withSources(gen2.toSourceFile()),
    )

    source2.writeText("changed")

    fileOperations.restoreFromCache(source2)

    currentFiles() shouldBe listOf(gen1.relativeFile, source1, source2)
  }

  @Test
  fun `restoreFromCache deletes any un-tracked files in the generated directory`() = test {

    fileOperations.addToCache(
      gen1.withSources(source1),
    )

    val untracked = generatedDir.resolve("untracked.kt")
      .createSafely("// this is not tracked")
      .let { AbsoluteFile(it).relativeTo(projectDir) }

    currentFiles() shouldBe listOf(gen1.relativeFile, untracked, source1)

    fileOperations.restoreFromCache()

    currentFiles() shouldBe listOf(gen1.relativeFile, source1)
  }

  @Test
  fun `restoreFromCache a deleted source file deletes the generated file`() = test {

    fileOperations.addToCache(
      gen1.withSources(source1),
      gen2.withSources(source2),
      gen3.withSources(gen2.toSourceFile()),
    )

    listOf(
      source1,
      gen1.toSourceFile(),
      gen2.toSourceFile(),
      gen3.toSourceFile(),
    )
      .forEach { it.absoluteFile.delete() }

    fileOperations.restoreFromCache()

    currentFiles() shouldBe listOf(gen2.relativeFile, gen3.relativeFile, source2)
  }
}
