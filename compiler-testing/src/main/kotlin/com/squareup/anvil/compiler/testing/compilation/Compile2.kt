package com.squareup.anvil.compiler.testing.compilation

import com.squareup.anvil.compiler.testing.CompilationEnvironment
import dagger.internal.codegen.ComponentProcessor
import io.kotest.matchers.shouldBe
import org.jetbrains.kotlin.cli.common.ExitCode
import org.jetbrains.kotlin.cli.common.arguments.K2JVMCompilerArguments
import org.jetbrains.kotlin.cli.common.arguments.copyOf
import org.jetbrains.kotlin.cli.common.arguments.parseCommandLineArguments
import org.jetbrains.kotlin.cli.jvm.K2JVMCompiler
import org.jetbrains.kotlin.compilerRunner.toArgumentStrings
import org.jetbrains.kotlin.config.LanguageVersion
import org.jetbrains.kotlin.incremental.isJavaFile
import org.jetbrains.kotlin.kapt3.base.AptMode
import org.jetbrains.kotlin.kapt3.base.DetectMemoryLeaksMode
import org.jetbrains.kotlin.kapt3.base.KaptFlag
import org.jetbrains.kotlin.kapt3.base.KaptOptions
import java.io.File
import java.io.InputStream
import java.io.OutputStreamWriter
import java.net.URI
import java.net.URLClassLoader
import javax.tools.Diagnostic
import javax.tools.DiagnosticCollector
import javax.tools.JavaFileObject
import javax.tools.SimpleJavaFileObject
import javax.tools.ToolProvider

/**
 * Represents a compiler invocation that can handle Kotlin and Java compilation, as well as
 * an optional KAPT pass. Used primarily by [CompilationEnvironment.compile2].
 *
 * @property config The [Compile2CompilationConfiguration] containing file paths, classpaths, and various optional flags.
 * @property expectedExitCode The exit code this compilation expects. Typically [ExitCode.OK].
 * @see CompilationEnvironment.compile2
 */
public class Compile2Compilation(
  public val config: Compile2CompilationConfiguration,
  public val expectedExitCode: ExitCode,
) {

  /** Renders compiler messages (errors, warnings, etc.) in a human-friendly format.  Now in color! */
  private val messageRenderer by lazy { ColorizedPlainTextMessageRenderer() }

  /**
   * Executes the compilation process. This includes:
   *
   * 1. **KAPT** (optional): If [Compile2CompilationConfiguration.useKapt] is `true`, a separate
   *    annotation processing pass is performed using [executeKapt].
   * 2. **Kotlin compilation**: Invokes the Kotlin compiler ([K2JVMCompiler]) for all sources,
   *    including those generated by KAPT if KAPT was used.
   * 3. **Java compilation** (optional): If Java files are found in the final sources, they are
   *    compiled via `javac` ([compileJava]).
   *
   * @return A [Compile2Result] containing the compilation result: class loader, exit code, etc.
   * @throws AssertionError if any stage's [ExitCode] does not match [expectedExitCode].
   */
  internal fun execute(): Compile2Result {

    val baseArgs = K2JVMCompilerArguments().also { args ->

      args.moduleName = "root"
      args.additionalJavaModules = emptyArray()

      args.jdkHome = config.jdkHome?.absolutePath
      args.languageVersion = config.languageVersion.versionString

      args.verbose = config.verbose
      args.version = config.verbose
      args.reportPerf = false

      // Still run the compiler (for kapt) even if there are no Kotlin files.
      args.allowNoSourceFiles = true

      // The stdlib, reflect, and scripting jars are only necessary for
      args.noStdlib = true
      args.noReflect = true
      args.disableStandardScript = true

      args.destination = config.classFilesDir.absolutePath

      args.classpath = config.compilationClasspath.classpathString()

      args.pluginClasspaths = config.compilerPluginClasspath
        .pathStrings()
        .toTypedArray()

      // All initial Kotlin sources (no KAPT output yet).
      args.freeArgs += config.sourceFiles.pathStrings()
    }

    // Validate the CLI arguments by parsing them again.
    parseCommandLineArguments<K2JVMCompilerArguments>(baseArgs.toArgumentStrings())

    if (config.firExtensions.isNotEmpty()) {
      // Register the FIR extensions, if any, via thread-local.
      Compile2CompilerPluginRegistrar.threadLocalParams.set(
        Compile2CompilerPluginRegistrar.Compile2RegistrarParams(
          firExtensionFactories = config.firExtensions,
        ),
      )
    }

    // KAPT invocation happens first, generating stubs and Java/Kotlin sources if necessary.
    if (config.useKapt) {
      executeKapt(baseArgs)
    }

    // Gather all sources post-KAPT (Java sources generated by KAPT plus original Kotlin sources).
    val allSources = config.sourceFiles
      .plus(config.kaptGeneratedSourcesDir.walkBottomUp().filter { it.isJavaFile() })
      .distinct()

    // Copy the base args again, but with the final set of source files.
    val mainPassArgs = baseArgs.copyOf().also { args ->
      args.freeArgs = allSources.pathStrings()
    }
      .toArgumentStrings()

    // Run the Kotlin compiler for everything. This is the main compilation pass.
    val exitCode = K2JVMCompiler().exec(
      errStream = System.out,
      messageRenderer = messageRenderer,
      args = mainPassArgs.toTypedArray(),
    )
    exitCode shouldBe expectedExitCode

    // If there are Java sources (either from the user or generated by KAPT), compile them separately.
    val javaSources = allSources.filter { it.isJavaFile() }
    if (javaSources.isNotEmpty()) {
      compileJava(javaSources)
    }

    // Build a classloader containing all compilation outputs plus the user-provided classpath.
    val classLoader = URLClassLoader.newInstance(
      config.compilationClasspath
        .plus(config.classFilesDir)
        .map { it.toURI().toURL() }
        .toTypedArray(),
    )

    return Compile2Result(
      rootDir = config.rootDir,
      libsDir = config.jarOutputDir,
      classFilesDir = config.classFilesDir,
      classpathFiles = config.compilationClasspath,
      exitCode = exitCode,
      classLoader = classLoader,
    ).apply {

      exitCode shouldBe expectedExitCode
    }
  }

  /**
   * Executes a separate KAPT pass using the Kotlin compiler before the main Kotlin compilation.
   *
   * 1. Builds [KaptOptions] to specify stubs directories, generated source directories, and so on.
   * 2. Sets up annotation processors. By default, this includes [ComponentProcessor] (Dagger).
   * 3. Invokes [K2JVMCompiler] with additional arguments controlling annotation processing.
   * 4. Produces stub classes and Java source files which will be picked up in the main compilation.
   *
   * @param baseArgs The [K2JVMCompilerArguments] to copy and modify for KAPT invocation.
   * @throws AssertionError if the KAPT pass does not match the [expectedExitCode].
   */
  private fun executeKapt(baseArgs: K2JVMCompilerArguments) {

    val kaptPassArgs = baseArgs.copyOf().also { args ->
      args.freeArgs = config.sourceFiles.pathStrings()
      args.useJavac = false // The KAPT pass itself doesn't delegate to `javac`.

      // The K2JVMCompilerArguments flag property for Kapt4 was renamed
      // from `useKapt4` to `useK2Kapt` in Kotlin 2.1.0.
      // We use the string version so that it's source-compatible.
      when {
        config.languageVersion < LanguageVersion.KOTLIN_2_0 -> Unit // Kapt4 requires 2.0+
        config.languageVersion == LanguageVersion.KOTLIN_2_0 -> {
          // aka `args.useKapt4 = true`
          args.freeArgs += "-Xuse-kapt4"
        }
        else -> {
          // aka `args.useK2Kapt = true`
          args.freeArgs += "-Xuse-k2-kapt"
        }
      }

      // This is the runtime classpath for the Kapt invocation.
      // Essentially, that's the Dagger compiler and the dependencies it references.
      val processingClasspath = listOf(
        HostClasspath.daggerCompiler,
        HostClasspath.jakartaInject,
        HostClasspath.javaxInject,
        HostClasspath.jetbrainsAnnotations,
      )

      val kaptOptions = KaptOptions.Builder().also { kapt ->
        kapt.detectMemoryLeaks = DetectMemoryLeaksMode.DEFAULT
        kapt.processors.add(ComponentProcessor::class.qualifiedName!!)
        kapt.classesOutputDir = config.kaptClassesDir.absoluteFile
        kapt.incrementalDataOutputDir = config.kaptIncrementalDir.absoluteFile
        kapt.processingClasspath += processingClasspath
        kapt.sourcesOutputDir = config.kaptGeneratedSourcesDir.absoluteFile
        kapt.stubsOutputDir = config.kaptStubsDir.absoluteFile
        kapt.mode = if (config.languageVersion >= LanguageVersion.KOTLIN_2_0) {
          AptMode.STUBS_AND_APT
        } else {
          AptMode.WITH_COMPILATION
        }

        kapt.flags.addAll(
          listOf(
            KaptFlag.USE_LIGHT_ANALYSIS,
            // Anything in the main compile classpath is also added to the kapt classpath.
            KaptFlag.INCLUDE_COMPILE_CLASSPATH,
          ),
        )

        if (config.verbose) {
          kapt.flags.add(KaptFlag.VERBOSE)
        }
      }

      args.pluginOptions = kaptOptions.toPluginOptions()
        .toTypedArray()
    }

    val exitCode = K2JVMCompiler().exec(
      errStream = System.out,
      messageRenderer = messageRenderer,
      args = kaptPassArgs.toArgumentStrings().toTypedArray(),
    )
    exitCode shouldBe expectedExitCode
  }

  /**
   * Compiles any Java files using `javac`. This step is only invoked if there are Java files
   * in the final set of sources (including any KAPT-generated .java files).
   *
   * @param javaSources A list of Java [File]s to compile.
   */
  @Suppress("ktlint:standard:comment-wrapping")
  private fun compileJava(javaSources: List<File>) {
    val javac = synchronized(ToolProvider::class.java) {
      ToolProvider.getSystemJavaCompiler()
    } ?: error("No system Java compiler found.")

    val javaFileManager = javac.getStandardFileManager(
      /* diagnosticListener = */ null,
      /* locale = */ null,
      /* charset = */ null,
    )
    val diagnosticCollector = DiagnosticCollector<JavaFileObject>()

    val javacArgs = buildList {
      if (config.verbose) {
        this.add("-verbose")
        this.add("-Xlint:path") // warn about invalid paths in CLI
        this.add("-Xlint:options") // warn about invalid options in CLI
        this.add("-Xlint:module") // warn about issues with the module system
      }

      this.addAll(listOf("-d", config.classFilesDir.absolutePath))

      this.add("-proc:none") // disable annotation processing

      if (config.allWarningsAsErrors) this.add("-Werror")

      // Also add Kotlin classes to javac classpath so references to them resolve properly.
      this.addAll(
        listOf(
          "-cp",
          (config.compilationClasspath + config.classFilesDir).classpathString(),
        ),
      )
    }

    // Convert each file into a JavaFileObject, then compile them all at once.
    val javacSuccess = javac.getTask(
      /* out */ OutputStreamWriter(System.out),
      /* fileManager */ javaFileManager,
      /* diagnosticListener */ diagnosticCollector,
      /* options */ javacArgs,
      /* classes */ null,
      /* compilationUnits */ javaSources.map { AnvilSimpleJavaFileObject(it.toURI()) },
    ).call()

    // Process warnings/errors.
    diagnosticCollector.diagnostics.forEach { diag ->
      when (diag.kind) {
        Diagnostic.Kind.ERROR -> error(diag.toString())
        Diagnostic.Kind.WARNING,
        Diagnostic.Kind.MANDATORY_WARNING,
        -> System.err.println(diag.toString())
        else -> println(diag.toString())
      }
    }

    val javaExitCode = if (javacSuccess) ExitCode.OK else ExitCode.COMPILATION_ERROR
    javaExitCode shouldBe expectedExitCode
  }
}

/**
 * A simple in-memory [SimpleJavaFileObject] for reading Java code from a [URI] rather
 * than from a local file. Used to feed source strings directly to `javac`.
 *
 * @constructor Creates a file object representing the Java source pointed to by [uri].
 */
private class AnvilSimpleJavaFileObject(uri: URI) :
  SimpleJavaFileObject(uri, JavaFileObject.Kind.SOURCE) {

  /**
   * Opens the [InputStream] from the underlying URL so `javac` can read the file's contents.
   */
  override fun openInputStream(): InputStream = uri.toURL().openStream()

  /**
   * Loads and returns the file contents as a [CharSequence].
   */
  override fun getCharContent(ignoreEncodingErrors: Boolean): CharSequence =
    uri.toURL().readText()
}

/**
 * @return The current `java.home` as a [File], or throws if not set. Typically used to
 * provide the Kotlin compiler arguments with a Java home directory.
 * @throws IllegalStateException if neither `JAVA_HOME` nor `java.home` is set.
 */
internal fun javaHome(): File = javaHomeOrNull() ?: error("JAVA_HOME and 'java.home' not set")

/**
 * @return The current Java home as a [File], or `null` if neither `JAVA_HOME` nor `java.home` is set.
 */
internal fun javaHomeOrNull(): File? {
  val path = System.getProperty("java.home")
    ?: System.getenv("JAVA_HOME")
    ?: return null

  return File(path).also { check(it.isDirectory) }
}

/**
 * Converts each [File] in this collection to its absolute path [String], de-duplicating entries.
 *
 * @return A list of distinct file path strings.
 */
internal fun Iterable<File>.pathStrings(): List<String> = map { it.absolutePath }.distinct()

/**
 * Joins all [File] paths in this collection into a single classpath [String],
 * separated by [File.pathSeparator].
 *
 * @return A classpath string suitable for compiler arguments.
 */
internal fun Iterable<File>.classpathString(): String =
  pathStrings().joinToString(File.pathSeparator)
