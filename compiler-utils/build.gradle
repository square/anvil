import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
  alias(libs.plugins.kotlin.jvm)
  alias(libs.plugins.mavenPublish)
  id 'java-test-fixtures'
}

kotlin {
  explicitApi()
}

def isIdeSync = getSystemProperty('idea.sync.active', 'false').toBoolean()

dependencies {
  api project(':annotations')
  api project(':compiler-api')
  api libs.kotlin.compiler
  api libs.kotlinpoet

  implementation libs.dagger2
  implementation libs.inject

  testFixturesApi libs.kotlin.compileTesting
  testFixturesImplementation project(':compiler')
  testFixturesImplementation libs.dagger2.compiler
  testFixturesImplementation libs.dagger2
  testFixturesImplementation libs.junit
  testFixturesImplementation libs.truth

  // Necessary because this is what dagger uses when it runs to support instantiating annotations at runtime
  testFixturesImplementation libs.auto.value.annotations
  testFixturesImplementation libs.auto.value.processor

  // This workaround is needed to resolve classes in the IDE properly.
  if (isIdeSync) {
    compileOnly project(':compiler')
    compileOnly libs.dagger2.compiler
    compileOnly libs.junit
    compileOnly libs.kotlin.compileTesting
    compileOnly libs.truth
  }
}

tasks.withType(KotlinCompile).configureEach {
  compilerOptions {
    freeCompilerArgs.add("-opt-in=org.jetbrains.kotlin.compiler.plugin.ExperimentalCompilerApi")
  }
}

private def getSystemProperty(String name, String defaultValue = null) {
  def provider = providers.systemProperty(name).forUseAtConfigurationTime()
  if (defaultValue) {
    return provider.getOrElse(defaultValue)
  } else {
    return provider.getOrNull()
  }
}

