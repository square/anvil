package com.squareup.anvil.annotations

import kotlin.annotation.AnnotationRetention.RUNTIME
import kotlin.annotation.AnnotationTarget.CLASS
import kotlin.reflect.KClass

/**
 * Similar to [MergeSubcomponent], but with the main difference that the subcomponent is generated
 * and modules, bindings and component interfaces are merged whenever the component with
 * [parentScope] is processed.
 *
 * Imagine this module dependency tree:
 * ```
 * :app -> :lib-a
 *     \-> :lib-b
 * ```
 * `:app` creates the component with `@MergeComponent`, `:lib-a` creates a subcomponent with
 * `@MergeSubcomponent` and `:lib-b` contributes a module to the scope of the subcomponent. This
 * module won't be included in the subcomponent without adding the dependency `:lib-a -> :lib-b`.
 *
 * On the other hand, if `:lib-a` uses `@ContributesSubcomponent` with a parent scope of the main
 * component from `:app`, then the actual subcomponent will be generated in the `:app` module and
 * the contributed module from `:lib-b` will be picked up.
 *
 * ```
 * @ContributesSubcomponent(
 *   scope = ActivityScope::class,
 *   parentScope = AppScope::class
 * )
 * interface ActivitySubcomponent
 * ```
 *
 * [parentScope] can be the scope of a [MergeComponent], [MergeSubcomponent] or another
 * [ContributesSubcomponent]. A chain of [ContributesSubcomponent]s is supported.
 *
 * It's possible to exclude any automatically added Dagger module or component interface with the
 * [exclude] parameter if needed.
 * ```
 * @ContributesSubcomponent(
 *   scope = ActivityScope::class,
 *   parentScope = AppScope::class,
 *   exclude = [
 *     DaggerModule::class,
 *     ComponentInterface::class
 *   ]
 * )
 * interface ActivitySubcomponent
 * ```
 *
 * It's recommended to define a parent component interface as inner class of the contributed
 * subcomponent that is contributed to the parent scope. Anvil will always generate a parent
 * component interface for the final generated subcomponent with an abstract factory method for
 * the subcomponent. If you create your own parent component interface, then the one generated by
 * Anvil will extend your interface. E.g.
 * ```
 * @ContributesSubcomponent(
 *   scope = ActivityScope::class,
 *   parentScope = AppScope::class
 * )
 * interface ActivitySubcomponent {
 *
 *   @ContributesTo(AppScope::class)
 *   interface ParentComponent {
 *     fun createActivityComponent(): ActivityComponent
 *   }
 * }
 * ```
 */
@Target(CLASS)
@Retention(RUNTIME)
@ExperimentalAnvilApi
public annotation class ContributesSubcomponent(
  /**
   * The scope used to find all contributed bindings, multibindings, modules and component
   * interfaces, which should be included in this subcomponent.
   */
  val scope: KClass<*>,

  /**
   * The actual subcomponent for this contributed subcomponent will be generated when a
   * [MergeComponent], [MergeSubcomponent] or another [ContributesSubcomponent] annotated component
   * with the same scope as `parentScope` is merged.
   */
  val parentScope: KClass<*>,
  /**
   * List of Dagger modules that should be manually included in the subcomponent and aren't
   * automatically contributed.
   */
  val modules: Array<KClass<*>> = [],
  /**
   * List of bindings, multibindings, modules and component interfaces that are contributed to the
   * same scope, but should be excluded from the subcomponent.
   */
  val exclude: Array<KClass<*>> = []
)
